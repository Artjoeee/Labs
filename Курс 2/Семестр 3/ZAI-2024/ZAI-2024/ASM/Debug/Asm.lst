Microsoft (R) Macro Assembler Version 14.41.34123.0	    12/18/24 13:09:06
Asm.asm							     Page 1 - 1


				.586
				.model flat, stdcall

				includelib libucrt.lib
				includelib kernel32.lib
				includelib "../Debug/LIB.lib"

				.stack 4096

				ExitProcess PROTO :DWORD
				outw PROTO : DWORD
				outwf PROTO : DWORD
				len PROTO : DWORD
				comp PROTO : DWORD, : DWORD

 00000000			.const
 00000000 0D 0A 00			newline byte 13, 10, 0
 00000003 74 72 75 65 00		true_str db 'true', 0
 00000008 66 61 6C 73 65		false_str db 'false', 0
	   00
 0000000E DD F2 EE 20 EF		L1 byte 'Это программа на языке ZAI-2024', 0
	   F0 EE E3 F0 E0
	   EC EC E0 20 ED
	   E0 20 FF E7 FB
	   EA E5 20 5A 41
	   49 2D 32 30 32
	   34 00
 0000002E C6 E0 EC EE E9		L2 byte 'Жамойдо Артем Игоревич', 0
	   E4 EE 20 C0 F0
	   F2 E5 EC 20 C8
	   E3 EE F0 E5 E2
	   E8 F7 00
 00000045 53 68 6F 77 00		L3 byte 'Show', 0
 0000004A 53 6E 6F 77 00		L4 byte 'Snow', 0
 0000004F 0000				L5 sword 0
 00000051 D1 F2 F0 EE EA		L6 byte 'Строки одинаковы', 0
	   E8 20 EE E4 E8
	   ED E0 EA EE E2
	   FB 00
 00000062 D0 E0 E7 ED FB		L7 byte 'Разные строки', 0
	   E5 20 F1 F2 F0
	   EE EA E8 00
 00000070 FFFF				L8 sword -1
 00000072 0002				L9 sword 2
 00000074 FFEC				L10 sword -20
 00000076 0014				L11 sword 20
 00000078 0003				L12 sword 3
 0000007A 0005				L13 sword 5
 0000007C 7D00				L14 sword 32000
 0000007E 0011				L15 sword 17
 00000080 0020				L16 sword 32
 00000082 61 00				L17 byte 'a', 0
 00000084 01				L18 byte 1
 00000085 0001				L19 sword 1
 00000087 6E 00				L20 byte 'n', 0
 00000089 50 00				L21 byte 'P', 0
 0000008B 00				L22 byte 0
 0000008C 00FF				L23 sword 255
 0000008E C4 EB E8 ED FB		L24 byte 'Длины строк совпадают', 0
	   20 F1 F2 F0 EE
	   EA 20 F1 EE E2
	   EF E0 E4 E0 FE
	   F2 00
 000000A4 C4 EB E8 ED FB		L25 byte 'Длины строк не совпадают', 0
	   20 F1 F2 F0 EE
	   EA 20 ED E5 20
	   F1 EE E2 EF E0
	   E4 E0 FE F2 00

 00000000			.data
 00000000 0000				temp sword ?
 00000002  00000100 [			buffer byte 256 dup(0)
	    00
	   ]
 00000102 00000000			fio dword ?
 00000106 00000000			author dword ?
 0000010A 00000000			str1 dword ?
 0000010E 00000000			str2 dword ?
 00000112 0000				answer1 sword 0
 00000114 0000				answer2 sword 0
 00000116 0000				math1 sword 0
 00000118 0000				math2 sword 0
 0000011A 0000				math3 sword 0
 0000011C 0000				math4 sword 0
 0000011E 0000				math5 sword 0
 00000120 0000				n sword 0
 00000122 0000				check1 sword 0
 00000124 0000				check2 sword 0
 00000126 0000				result2 sword 0
 00000128 00				chr1 byte 0
 00000129 00				condition1 byte 0
 0000012A 0000				bin1 sword 0
 0000012C 00				chr2 byte 0
 0000012D 00				condition2 byte 0
 0000012E 0000				bin2 sword 0
 00000130 0000				sum sword 0
 00000132 0000				strc1 sword 0
 00000134 0000				strc2 sword 0
 00000136 00000000			text dword ?
 0000013A 0000				left word ?
 0000013C 0000				right word ?
 0000013E 0000				result sword ?
 00000140  00000004 [			result_str byte 4 dup(0)
	    00
	   ]

 00000000			.code
 00000000				int_to_char PROC uses eax ebx ecx edi esi,
						pstr: dword, ; Указатель на строку
						intfield : sdword; Число для преобразования в строку
 00000008  53					push ebx
 00000009  51					push ecx
 0000000A  52					push edx
 0000000B  8B 7D 08				mov edi, pstr; Указатель на начало строки
 0000000E  8B 45 0C				mov eax, intfield
 00000011  99					cdq
						; Проверка на отрицательное число
 00000012  A9 80000000				test eax, 80000000h
 00000017  74 08				jz positive
 00000019  F7 D8				neg eax
 0000001B  F7 DA				neg edx
 0000001D  C6 07 2D				mov byte ptr[edi], '-'
 00000020  47					inc edi; Сдвигаем указатель на следующую позицию
 00000021					positive :
						; Преобразование числа в строку
 00000021  BB 0000000A				mov ebx, 10
 00000026  33 C9				xor ecx, ecx
 00000028					convert_loop:
 00000028  33 D2				xor edx, edx
 0000002A  F7 F3				div ebx; Делим число на 10, результат в eax, остаток в edx
 0000002C  80 C2 30				add dl, '0'; Преобразуем остаток в ASCII
 0000002F  66| 52				push dx
 00000031  41					inc ecx; Увеличиваем счётчик цифр
 00000032  85 C0				test eax, eax; Проверяем, не делим ли мы ноль
 00000034  75 F2				jnz convert_loop; Если не ноль, продолжаем делить
						; Запись цифр в строку
 00000036					write_digits :
 00000036  66| 5A				pop dx; Извлекаем цифру из стека
 00000038  88 17				mov[edi], dl; Записываем её в строку
 0000003A  47					inc edi
 0000003B  E2 F9				loop write_digits; Повторяем для всех цифр
						; Завершаем строку нулём
 0000003D  C6 07 00				mov byte ptr[edi], 0
 00000040  5A					pop edx
 00000041  59					pop ecx
 00000042  5B					pop ebx
						ret
 0000004C				int_to_char ENDP

 0000004C			show_text PROC 

 0000004C  66| 53		push bx
 0000004E  66| 52		push dx

				INVOKE outwf, offset L1


 0000005A  66| 5A		pop dx
 0000005C  66| 5B		pop bx
 0000005E  C3			ret
 0000005F			show_text ENDP

 0000005F			show_name PROC,
					show_namename : word  
 00000062  66| 53		push bx
 00000064  66| 52		push dx

 00000066  66| 5A		pop dx
 00000068  66| 5B		pop bx
 0000006A  66| 8B 45 08		mov ax, show_namename
				ret
 00000072			show_name ENDP


 00000072			main PROC

 00000072  E8 FFFFFFD5		call show_text

 00000077  C7 05 00000102 R	mov fio, offset L2
	   0000002E R
 00000081  8B 0D 00000102 R	mov ecx, fio
 00000087  89 0D 00000106 R	mov author, ecx

				INVOKE outwf, author

 00000098  C7 05 0000010A R	mov str1, offset L3
	   00000045 R
 000000A2  C7 05 0000010E R	mov str2, offset L4
	   0000004A R
 000000AC  FF 35 0000010A R	push str1
 000000B2  FF 35 0000010E R	push str2
 000000B8  E8 00000000 E	call comp
 000000BD  66| 50		push ax

 000000BF  66| 5B		pop bx
 000000C1  66| 89 1D		mov answer1, bx
	   00000112 R

 000000C8  FF 35 0000010A R	push str1
 000000CE  FF 35 0000010A R	push str1
 000000D4  E8 00000000 E	call comp
 000000D9  66| 50		push ax

 000000DB  66| 5B		pop bx
 000000DD  66| 89 1D		mov answer2, bx
	   00000114 R

 000000E4  66| A1		mov ax, answer1
	   00000112 R
 000000EA  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 0000010C  66| A1		mov ax, answer2
	   00000114 R
 00000112  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 00000134  66| FF 35		push answer2
	   00000114 R

 0000013B  66| 5B		pop bx
 0000013D  66| 89 1D		mov left, bx
	   0000013A R

 00000144  66| FF 35		push L5
	   0000004F R

 0000014B  66| 5B		pop bx
 0000014D  66| 89 1D		mov right, bx
	   0000013C R

 00000154  66| 8B 15		mov dx, left
	   0000013A R
 0000015B  66| 3B 15		cmp dx, right
	   0000013C R

 00000162  7F 02		jg right1
 00000164  7E 0C		jle wrong1
 00000166			right1:

				INVOKE outwf, offset L6


 00000170  EB 0A		jmp next1
 00000172			wrong1:

				INVOKE outwf, offset L7

 0000017C			next1:
 0000017C  66| FF 35		push L8
	   00000070 R
 00000183  66| FF 35		push L9
	   00000072 R
 0000018A  66| 5B		pop bx
 0000018C  66| 58		pop ax
 0000018E  66| 2B C3		sub ax, bx
 00000191  66| 50		push ax

 00000193  66| 5B		pop bx
 00000195  66| 89 1D		mov math1, bx
	   00000116 R

 0000019C  66| FF 35		push L10
	   00000074 R
 000001A3  66| FF 35		push L9
	   00000072 R
 000001AA  66| 5B		pop bx
 000001AC  66| 58		pop ax
 000001AE  66| 03 C3		add ax, bx
 000001B1  66| 50		push ax

 000001B3  66| 5B		pop bx
 000001B5  66| 89 1D		mov math2, bx
	   00000118 R

 000001BC  66| FF 35		push L11
	   00000076 R
 000001C3  66| FF 35		push L12
	   00000078 R

 000001CA  66| 5B		pop bx
 000001CC  66| 58		pop ax
 000001CE  66| 85 DB		test bx, bx
 000001D1  0F 84 00000444	jz EXIT_DIV_ON_NULL
 000001D7  99			cdq
 000001D8  66| F7 FB		idiv bx
 000001DB  66| 52		push dx

 000001DD  66| 5B		pop bx
 000001DF  66| 89 1D		mov math3, bx
	   0000011A R

 000001E6  66| FF 35		push L11
	   00000076 R
 000001ED  66| FF 35		push L9
	   00000072 R
 000001F4  66| 5B		pop bx
 000001F6  66| 58		pop ax
 000001F8  66| 0F AF C3		imul ax, bx
 000001FC  66| 50		push ax

 000001FE  66| 5B		pop bx
 00000200  66| 89 1D		mov math4, bx
	   0000011C R

 00000207  66| FF 35		push L11
	   00000076 R
 0000020E  66| FF 35		push L13
	   0000007A R

 00000215  66| 5B		pop bx
 00000217  66| 58		pop ax
 00000219  66| 85 DB		test bx, bx
 0000021C  0F 84 000003F9	jz EXIT_DIV_ON_NULL
 00000222  99			cdq
 00000223  66| F7 FB		idiv bx
 00000226  66| 50		push ax

 00000228  66| 5B		pop bx
 0000022A  66| 89 1D		mov math5, bx
	   0000011E R

 00000231  66| A1		mov ax, math1
	   00000116 R
 00000237  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 00000259  66| A1		mov ax, math2
	   00000118 R
 0000025F  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 00000281  66| A1		mov ax, math3
	   0000011A R
 00000287  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 000002A9  66| A1		mov ax, math4
	   0000011C R
 000002AF  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 000002D1  66| A1		mov ax, math5
	   0000011E R
 000002D7  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 000002F9  66| FF 35		push L14
	   0000007C R

 00000300  66| 5B		pop bx
 00000302  66| 89 1D		mov n, bx
	   00000120 R

 00000309  66| FF 35		push L15
	   0000007E R

 00000310  66| 5B		pop bx
 00000312  66| 89 1D		mov check1, bx
	   00000122 R

 00000319  66| FF 35		push L16
	   00000080 R

 00000320  66| 5B		pop bx
 00000322  66| 89 1D		mov check2, bx
	   00000124 R

 00000329  66| FF 35		push check1
	   00000122 R
 00000330  66| FF 35		push check2
	   00000124 R
 00000337  66| 5B		pop bx
 00000339  66| 58		pop ax
 0000033B  66| 03 C3		add ax, bx
 0000033E  66| 50		push ax

 00000340  66| 5B		pop bx
 00000342  66| 89 1D		mov result2, bx
	   00000126 R

 00000349  66| A1		mov ax, check1
	   00000122 R
 0000034F  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 00000371  66| A1		mov ax, check2
	   00000124 R
 00000377  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 00000399  66| A1		mov ax, result2
	   00000126 R
 0000039F  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 000003C1  C6 05 00000128 R	mov byte ptr [chr1], 'a'
	   61
 000003C8  C6 05 00000129 R	mov byte ptr [chr1 + 1], 0
	   00
				INVOKE outwf, offset chr1

 000003D9  A0 00000084 R	mov al, byte ptr [L18]
 000003DE  A2 00000129 R	mov [condition1], al

 000003E3  80 3D 00000129 R	cmp condition1, 1
	   01
 000003EA  74 17		je print_true_condition1

 000003EC  C7 05 00000136 R	mov text, offset false_str
	   00000008 R
				INVOKE outwf, text
 00000401  EB 15		jmp done_condition1

 00000403			print_true_condition1:
 00000403  C7 05 00000136 R	mov text, offset true_str
	   00000003 R
				INVOKE outwf, text

 00000418			done_condition1:

 00000418  66| FF 35		push L19
	   00000085 R

 0000041F  66| 5B		pop bx
 00000421  66| 89 1D		mov bin1, bx
	   0000012A R

 00000428  66| A1		mov ax, bin1
	   0000012A R
 0000042E  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 00000450  C6 05 0000012C R	mov byte ptr [chr2], 'n'
	   6E
 00000457  C6 05 0000012D R	mov byte ptr [chr2 + 1], 0
	   00
 0000045E  C6 05 0000012C R	mov byte ptr [chr2], 'P'
	   50
 00000465  C6 05 0000012D R	mov byte ptr [chr2 + 1], 0
	   00
				INVOKE outwf, offset chr2

 00000476  A0 0000008B R	mov al, byte ptr [L22]
 0000047B  A2 0000012D R	mov [condition2], al

 00000480  80 3D 0000012D R	cmp condition2, 1
	   01
 00000487  74 17		je print_true_condition2

 00000489  C7 05 00000136 R	mov text, offset false_str
	   00000008 R
				INVOKE outwf, text
 0000049E  EB 15		jmp done_condition2

 000004A0			print_true_condition2:
 000004A0  C7 05 00000136 R	mov text, offset true_str
	   00000003 R
				INVOKE outwf, text

 000004B5			done_condition2:

 000004B5  66| FF 35		push L23
	   0000008C R

 000004BC  66| 5B		pop bx
 000004BE  66| 89 1D		mov bin2, bx
	   0000012E R

 000004C5  66| A1		mov ax, bin2
	   0000012E R
 000004CB  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 000004ED  66| FF 35		push bin1
	   0000012A R
 000004F4  66| FF 35		push bin2
	   0000012E R
 000004FB  66| 5B		pop bx
 000004FD  66| 58		pop ax
 000004FF  66| 03 C3		add ax, bx
 00000502  66| 50		push ax

 00000504  66| 5B		pop bx
 00000506  66| 89 1D		mov sum, bx
	   00000130 R

 0000050D  66| A1		mov ax, sum
	   00000130 R
 00000513  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 00000535  FF 35 0000010A R	push str1
 0000053B  E8 00000000 E	call len
 00000540  66| 50		push ax
 00000542  66| FF 35		push L19
	   00000085 R
 00000549  66| 5B		pop bx
 0000054B  66| 58		pop ax
 0000054D  66| 03 C3		add ax, bx
 00000550  66| 50		push ax

 00000552  66| 5B		pop bx
 00000554  66| 89 1D		mov strc1, bx
	   00000132 R

 0000055B  FF 35 0000010E R	push str2
 00000561  E8 00000000 E	call len
 00000566  66| 50		push ax

 00000568  66| 5B		pop bx
 0000056A  66| 89 1D		mov strc2, bx
	   00000134 R

 00000571  66| A1		mov ax, strc1
	   00000132 R
 00000577  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 00000599  66| A1		mov ax, strc2
	   00000134 R
 0000059F  66| A3		mov result, ax
	   0000013E R
				INVOKE int_to_char, offset result_str, result
				INVOKE outwf, offset result_str

 000005C1  66| FF 35		push strc1
	   00000132 R

 000005C8  66| 5B		pop bx
 000005CA  66| 89 1D		mov left, bx
	   0000013A R

 000005D1  66| FF 35		push strc2
	   00000134 R

 000005D8  66| 5B		pop bx
 000005DA  66| 89 1D		mov right, bx
	   0000013C R

 000005E1  66| 8B 15		mov dx, left
	   0000013A R
 000005E8  66| 3B 15		cmp dx, right
	   0000013C R

 000005EF  74 02		jz right2
 000005F1  75 0C		jnz wrong2
 000005F3			right2:
 000005F3  C7 05 00000136 R	mov text, offset L24
	   0000008E R

 000005FD  EB 0A		jmp next2
 000005FF			wrong2:
 000005FF  C7 05 00000136 R	mov text, offset L25
	   000000A4 R
 00000609			next2:

				INVOKE outwf, text

				INVOKE ExitProcess,0
 0000061B			EXIT_DIV_ON_NULL:
				INVOKE ExitProcess,-1
 00000622			main ENDP
				end main
Microsoft (R) Macro Assembler Version 14.41.34123.0	    12/18/24 13:09:06
Asm.asm							     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

CONST  . . . . . . . . . . . . .	32 Bit	 000000BD Para	  Public  'CONST'	 ReadOnly
FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000144 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000622 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
comp . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
int_to_char  . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 0000004C Public STDCALL
  pstr . . . . . . . . . . . . .	DWord	 bp + 00000008
  intfield . . . . . . . . . . .	DWord	 bp + 0000000C
  positive . . . . . . . . . . .	L Near	 00000021 _TEXT	
  convert_loop . . . . . . . . .	L Near	 00000028 _TEXT	
  write_digits . . . . . . . . .	L Near	 00000036 _TEXT	
len  . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
main . . . . . . . . . . . . . .	P Near	 00000072 _TEXT	Length= 000005B0 Public STDCALL
  right1 . . . . . . . . . . . .	L Near	 00000166 _TEXT	
  wrong1 . . . . . . . . . . . .	L Near	 00000172 _TEXT	
  next1  . . . . . . . . . . . .	L Near	 0000017C _TEXT	
  print_true_condition1  . . . .	L Near	 00000403 _TEXT	
  done_condition1  . . . . . . .	L Near	 00000418 _TEXT	
  print_true_condition2  . . . .	L Near	 000004A0 _TEXT	
  done_condition2  . . . . . . .	L Near	 000004B5 _TEXT	
  right2 . . . . . . . . . . . .	L Near	 000005F3 _TEXT	
  wrong2 . . . . . . . . . . . .	L Near	 000005FF _TEXT	
  next2  . . . . . . . . . . . .	L Near	 00000609 _TEXT	
  EXIT_DIV_ON_NULL . . . . . . .	L Near	 0000061B _TEXT	
outwf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
outw . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
show_name  . . . . . . . . . . .	P Near	 0000005F _TEXT	Length= 00000013 Public STDCALL
  show_namename  . . . . . . . .	Word	 bp + 00000008
show_text  . . . . . . . . . . .	P Near	 0000004C _TEXT	Length= 00000013 Public STDCALL


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
L10  . . . . . . . . . . . . . .	Word	 00000074 CONST	
L11  . . . . . . . . . . . . . .	Word	 00000076 CONST	
L12  . . . . . . . . . . . . . .	Word	 00000078 CONST	
L13  . . . . . . . . . . . . . .	Word	 0000007A CONST	
L14  . . . . . . . . . . . . . .	Word	 0000007C CONST	
L15  . . . . . . . . . . . . . .	Word	 0000007E CONST	
L16  . . . . . . . . . . . . . .	Word	 00000080 CONST	
L17  . . . . . . . . . . . . . .	Byte	 00000082 CONST	
L18  . . . . . . . . . . . . . .	Byte	 00000084 CONST	
L19  . . . . . . . . . . . . . .	Word	 00000085 CONST	
L1 . . . . . . . . . . . . . . .	Byte	 0000000E CONST	
L20  . . . . . . . . . . . . . .	Byte	 00000087 CONST	
L21  . . . . . . . . . . . . . .	Byte	 00000089 CONST	
L22  . . . . . . . . . . . . . .	Byte	 0000008B CONST	
L23  . . . . . . . . . . . . . .	Word	 0000008C CONST	
L24  . . . . . . . . . . . . . .	Byte	 0000008E CONST	
L25  . . . . . . . . . . . . . .	Byte	 000000A4 CONST	
L2 . . . . . . . . . . . . . . .	Byte	 0000002E CONST	
L3 . . . . . . . . . . . . . . .	Byte	 00000045 CONST	
L4 . . . . . . . . . . . . . . .	Byte	 0000004A CONST	
L5 . . . . . . . . . . . . . . .	Word	 0000004F CONST	
L6 . . . . . . . . . . . . . . .	Byte	 00000051 CONST	
L7 . . . . . . . . . . . . . . .	Byte	 00000062 CONST	
L8 . . . . . . . . . . . . . . .	Word	 00000070 CONST	
L9 . . . . . . . . . . . . . . .	Word	 00000072 CONST	
answer1  . . . . . . . . . . . .	Word	 00000112 _DATA	
answer2  . . . . . . . . . . . .	Word	 00000114 _DATA	
author . . . . . . . . . . . . .	DWord	 00000106 _DATA	
bin1 . . . . . . . . . . . . . .	Word	 0000012A _DATA	
bin2 . . . . . . . . . . . . . .	Word	 0000012E _DATA	
buffer . . . . . . . . . . . . .	Byte	 00000002 _DATA	
check1 . . . . . . . . . . . . .	Word	 00000122 _DATA	
check2 . . . . . . . . . . . . .	Word	 00000124 _DATA	
chr1 . . . . . . . . . . . . . .	Byte	 00000128 _DATA	
chr2 . . . . . . . . . . . . . .	Byte	 0000012C _DATA	
condition1 . . . . . . . . . . .	Byte	 00000129 _DATA	
condition2 . . . . . . . . . . .	Byte	 0000012D _DATA	
false_str  . . . . . . . . . . .	Byte	 00000008 CONST	
fio  . . . . . . . . . . . . . .	DWord	 00000102 _DATA	
left . . . . . . . . . . . . . .	Word	 0000013A _DATA	
math1  . . . . . . . . . . . . .	Word	 00000116 _DATA	
math2  . . . . . . . . . . . . .	Word	 00000118 _DATA	
math3  . . . . . . . . . . . . .	Word	 0000011A _DATA	
math4  . . . . . . . . . . . . .	Word	 0000011C _DATA	
math5  . . . . . . . . . . . . .	Word	 0000011E _DATA	
newline  . . . . . . . . . . . .	Byte	 00000000 CONST	
n  . . . . . . . . . . . . . . .	Word	 00000120 _DATA	
result2  . . . . . . . . . . . .	Word	 00000126 _DATA	
result_str . . . . . . . . . . .	Byte	 00000140 _DATA	
result . . . . . . . . . . . . .	Word	 0000013E _DATA	
right  . . . . . . . . . . . . .	Word	 0000013C _DATA	
str1 . . . . . . . . . . . . . .	DWord	 0000010A _DATA	
str2 . . . . . . . . . . . . . .	DWord	 0000010E _DATA	
strc1  . . . . . . . . . . . . .	Word	 00000132 _DATA	
strc2  . . . . . . . . . . . . .	Word	 00000134 _DATA	
sum  . . . . . . . . . . . . . .	Word	 00000130 _DATA	
temp . . . . . . . . . . . . . .	Word	 00000000 _DATA	
text . . . . . . . . . . . . . .	DWord	 00000136 _DATA	
true_str . . . . . . . . . . . .	Byte	 00000003 CONST	

	   0 Warnings
	   0 Errors
